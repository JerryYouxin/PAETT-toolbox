#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif
#include <sched.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <stdint.h>
#include <signal.h>
#include <papi.h>
#include <cassert>
#include <string.h>

#include <sys/file.h>
#include <unistd.h>

#define PREALLOCATE_CCT
#define MULTI_THREAD
#define USE_OPENMP 1

#include "CallingContextTree.h"
#include "common.h"
// configure file auto generated by PAETT configuration
#include "config.h"

#include <sys/syscall.h> 
#define MAXEVENT 10

#define GET_THREADID PAPI_thread_id()

#define METRIC_FN "metric.out"

#ifdef MULTI_THREAD
#define MAX_THREAD 1
#define GET_THREADID PAPI_thread_id()
#ifdef USE_PTHREAD
    #define THREAD_HANDLER pthread_self
    #define GET_ACTIVE_THREAD_NUM 1
#elif (USE_OPENMP==1)
    #include <omp.h>
    #define THREAD_HANDLER omp_get_thread_num
    #define GET_ACTIVE_THREAD_NUM std::max(omp_get_max_threads(),1)
#else
    #error "Only USE_PTHREAD or USE_OPENMP is supportted!"
#endif
#else
#define MAX_THREAD 1
#define GET_THREADID 0
#define GET_ACTIVE_THREAD_NUM 1
#endif

#ifdef ENABLE_DEBUG_LOG
FILE* RAPL_LOG;
#define RAPL_LOG_FN "energy_utils.log"
#define RLOG_INIT do { RAPL_LOG = fopen(RAPL_LOG_FN, "a+"); if(!RAPL_LOG) printf("Error to open RAPL_LOG: %s\n", RAPL_LOG_FN); } while(0)
#define RLOG(msg, ...) if(RAPL_LOG) fprintf(RAPL_LOG, msg, ##__VA_ARGS__)
#define RLOG_FINI fclose(RAPL_LOG)
#else
#define RLOG_INIT 
#define RLOG(msg, ...) 
#define RLOG_FINI 
#endif

static uint64_t* eventDataBuffer[MAX_THREAD];
static uint64_t eventDataBufferIndex[MAX_THREAD];
static CallingContextLog* root[MAX_THREAD];
static CallingContextLog* cur[MAX_THREAD] = {0};
static bool danger[MAX_THREAD] = {false};
static int* _eventList;
// PAPI global vars
static uint8_t initialized = 0;
static int EventSet = PAPI_NULL;
static int eventNum = 0;
uint64_t elapsed_us;
uint64_t elapsed_cyc;

uint64_t elapsed_us_multi[MAX_THREAD] = {0};
uint64_t begin_us_multi[MAX_THREAD];

//#define STOP_WHEN_WARN
//#define ENABLE_INFO_LOG
#ifdef ENABLE_INFO_LOG
#define INFO(msg, ...) printf("INFO: "); printf(msg, ##__VA_ARGS__); fflush(stdout)
#else
#define INFO(msg, ...)
#endif

#ifdef DEBUG_PAPI
#define CHECK_PAPI(stmt, PASS) printf("%s:%d: Executing %s\n",__FILE__, __LINE__,#stmt); fflush(stdout); if((retval=stmt)!=PASS) handle_error(retval)
#else
#define CHECK_PAPI(stmt, PASS) if((retval=stmt)!=PASS) handle_error(retval)
#endif
#define CHECK_PAPI_ISOK(stmt) CHECK_PAPI(stmt, PAPI_OK)
#define handle_error(e) do { fprintf(stderr, "Error at %s:%d: %s\n",__FILE__, __LINE__, PAPI_strerror(e)); exit(1); } while(0)

// C-style interfaces for lib call
extern "C" void PAETT_print();
extern "C" void PAETT_inst_init();
extern "C" void PAETT_inst_enter(uint64_t key); // key = MAKE_KEY(mid, l_key)
extern "C" void PAETT_inst_exit(uint64_t key);
extern "C" void PAETT_inst_thread_init(uint64_t key); // key = MAKE_KEY(mid, l_key)
extern "C" void PAETT_inst_thread_fini(uint64_t key);
extern "C" void PAETT_inst_finalize();

// Debug logging
#define LIBPAETT_INST_LOGFN "libpaett_inst.log"
static FILE* LOG;

#include "energy_utils.h"

#define COUNT_FN ".paett_collect.cnt"
#define METRIC_FN "metric.out"

void PAETT_print() {
#ifndef DISABLE_PAPI_SAMPLING
    printf("\n=========== USING PAPI & Instrumentation =============\n");
#else
    printf("\n============ ONLY USING Instrumentation ==============\n");
#endif
#ifdef MULTI_THREAD
    printf("========== Multi Thread Support Enabled!! ============\n");
#else
    printf("========= Multi Thread Support Disabled!! ============\n");
#endif
}

static std::vector<std::string> ename;
int es, ee;

static bool detection_mode = false;
static bool collect_energy = false;
static double init_energy;

static const char* _pre_ename[MAXEVENT] = {
    "ENERGY",
    "PAPI_BR_NTK",
    "PAPI_LD_INS",
    "PAPI_L2_ICR",
    "PAPI_BR_MSP", // PEBS
    "PAPI_RES_STL",
    "PAPI_SR_INS", // PEBS
    "PAPI_L2_DCR" // PEBS
};
static int _pre_esize = 8;

static long long counterVal[MAXEVENT] = {0};
static uint64_t g_cycles[MAX_THREAD] = {0};

std::string profile_path;

#define SIGNIFICANT_REGION_DETECT_LOG "significant_regions.log"

bool __PAETT_detect_init() {
#ifndef USE_SEPERATE_DETECT
    return false;
#else
    int retval;
    FILE* fp = fopen(SIGNIFICANT_REGION_DETECT_LOG,"rb");
    if(fp==NULL) {
        for(int i=0;i<MAX_THREAD;++i) {
            cur[i]=root[i];
            cur[i]->data.size = 0;
        }
        CHECK_PAPI(PAPI_library_init(PAPI_VER_CURRENT), PAPI_VER_CURRENT);
#ifdef MULTI_THREAD
        CHECK_PAPI_ISOK(PAPI_thread_init(THREAD_HANDLER));
#endif
        printf("INFO: Will Running in detection mode for significant region detection\n");
        detection_mode = true;
    } else {
        auto rd = CallingContextLog::read(fp);
        fclose(fp);
        root[0]->copyCCTPath(rd);
        delete rd;
        detection_mode = false;
    }
    return detection_mode;
#endif
}

void __PAETT_detect_finalize() {
    pruneCCTWithThreshold(root[0], PRUNE_THRESHOLD);
    CallingContextLog::fprint(SIGNIFICANT_REGION_DETECT_LOG, root[0]);
}

uint64_t* __allocate_eventLogSpace(int i, uint64_t s) {
    assert(i>=0);
    assert(i<MAX_THREAD);
    //printf("[%d]: Allocate Size %lu B, Avail %lu B, Used %lu B\n",i, s, (eventNum*2*CCT_PREALLOCATE_SIZE)-eventDataBufferIndex[i], eventDataBufferIndex[i]);
    //fflush(stdout);
    uint64_t* res = &(eventDataBuffer[i][eventDataBufferIndex[i]]);
    eventDataBufferIndex[i]+=s;
    assert(eventDataBufferIndex[i]<=eventNum*2*CCT_PREALLOCATE_SIZE);
    return res;
}

void __preallocate_fini() {
    for(int i=0;i<MAX_THREAD;++i) {
        free(eventDataBuffer[i]);
    }
}

void PAETT_inst_init() {
    int retval, i;
    if(initialized) {
        fprintf(stderr, "Error Duplicated initialization!!!\n");
        exit(EXIT_FAILURE);
    }
    danger[0]=true;
    LOG = fopen(LIBPAETT_INST_LOGFN,"w");
    if(__PAETT_detect_init()) {
        danger[0]=false;
        ++(cur[0]->data.ncall);
        initialized = true;
        g_cycles[0] = PAPI_get_real_usec();
        assert(detection_mode);
        return;
    }
    assert(!detection_mode);
    FILE* efile = fopen("profile.event","r");
    if(efile==NULL) {
        printf("INFO: profile.event not found for profiling! Use predefined event set.\n");
        int i;
        for(i=0;i<_pre_esize;++i) {
            std::string en_str = std::string(_pre_ename[i]);
            if(en_str==std::string("ENERGY")) {
                collect_energy = true;
            } else {
                ename.push_back(en_str);
            }
        }
    } else {
        char en[50];
        while(EOF!=fscanf(efile, "%s", en)) {
            std::string en_str = std::string(en);
            if(en_str==std::string("ENERGY")) {
                collect_energy = true;
            } else {
                ename.push_back(en_str);
            }
        }
        fclose(efile);
    }
    // PROFILE PATH
    char* envPath = getenv("PAETT_OUTPUT_PATH");
    if(envPath) {
        profile_path = std::string(envPath);
    } else {
        profile_path = std::string("./");
    }
    // other settings
    eventNum=ename.size(); 
    int* eventList = (int*)malloc(sizeof(int)*eventNum);
#ifdef MULTI_THREAD
    _eventList = eventList;
#endif
    if(eventNum<=0) return ; // no perf event encountered
    /* Initialize the PAPI library */
    CHECK_PAPI(PAPI_library_init(PAPI_VER_CURRENT), PAPI_VER_CURRENT);
    // check for available counters
    int numCounter = PAPI_num_counters();
    es=0, ee=eventNum;
    if(eventNum>numCounter) {
        printf("Error: Too much event is configured (%d events but the platform only support maximum %d events at a time)\n", eventNum, numCounter);
        exit(1);
    }
    // preallocate cct nodes and data spaces for metrics
    for(i=0;i<MAX_THREAD;++i) {
        eventDataBuffer[i] = (uint64_t*)malloc(sizeof(uint64_t)*eventNum*2*CCT_PREALLOCATE_SIZE);
        if(eventDataBuffer[i]==NULL) {
            printf("Failed to allocate memory!!!\n");
            exit(1);
        }
        memset(eventDataBuffer[i], 0, sizeof(uint64_t)*eventNum*2*CCT_PREALLOCATE_SIZE);
        eventDataBufferIndex[i] = 0;
        root[i] = CallingContextLog::get();
        cur[i]=root[i];
        cur[i]->data.size = eventNum;
        cur[i]->data.eventData = __allocate_eventLogSpace(i, eventNum*2);// (uint64_t*)malloc(sizeof(uint64_t)*eventNum*2);
    }
#ifdef MULTI_THREAD
    CHECK_PAPI_ISOK(PAPI_thread_init(THREAD_HANDLER));
#endif
    assert(GET_THREADID==0);
    printf("NumCounter: %d, Will Add %d Events\n",numCounter, eventNum); fflush(stdout);
    /* Create the EventSet */
    CHECK_PAPI_ISOK(PAPI_create_eventset(&EventSet)); fflush(stdout);
    printf("EventSet: %d\n", EventSet);
    /* Add Events to our created EventSet */
    for(i=es;i<ee;++i) {
        //CHECK_PAPI_ISOK(PAPI_event_code_to_name(eventList[i], ename));
        CHECK_PAPI_ISOK(PAPI_event_name_to_code(ename[i].c_str(), &eventList[i]));
        printf("Add Event: [%lx]", eventList[i]);  fflush(stdout);
        printf("%s\n", ename[i].c_str()); fflush(stdout);
        CHECK_PAPI_ISOK(PAPI_add_event(EventSet, eventList[i]));
    }
    /* Init for energy collection if enabled */
    if(collect_energy) {
        if(energy_init()!=0) {
            printf("Energy Collection Initialization Failed!\n");
            exit(1);
        }
    }
    danger[0]=false;
    /* Start counting */
    elapsed_us = PAPI_get_real_usec();
	elapsed_cyc = PAPI_get_real_cyc();
    CHECK_PAPI_ISOK(PAPI_start(EventSet));
    CHECK_PAPI_ISOK(PAPI_read(EventSet, &(cur[0]->data.eventData[eventNum])));
    ++(cur[0]->data.ncall);
    initialized = 1;
    init_energy = get_pkg_energy();
    cur[0]->data.last_energy = init_energy;
    g_cycles[0] = PAPI_get_real_usec();
}
#ifdef MULTI_THREAD
// actually should be inserted after PAETT_inst_enter
void PAETT_inst_thread_init(uint64_t key) {
    // int retval, i;
    // // CHECK_PAPI_ISOK(PAPI_stop(EventSet, counterVal));
    int tid = GET_THREADID;
    // printf("thread_init for 0x%lx @ 0x%lx: tid=%d,danger=%d,initialized=%d\n",key,cur[tid]->key,tid,danger[tid],initialized); fflush(stdout);
    assert(tid<MAX_THREAD && "Thread number exceeds preallocated size!!!");
    assert(cur[tid] && !danger[tid] && initialized);
    if(cur[tid]->key!=key) {
        PAETT_inst_enter(key);
        // printf("After Enter: thread_init for 0x%lx @ 0x%lx\n",key,cur[tid]->key); fflush(stdout);
    }
    danger[tid] = true;
    // we should have already called PAETT_inst_enter
    assert(cur[tid] && cur[tid]->key==key);
    // Stop counting first to disable overflow
    cur[tid]->data.active_thread = std::max(cur[tid]->data.active_thread, (uint64_t)GET_ACTIVE_THREAD_NUM);
}
// Different from init, the fini instrumentation will do the work similiarly as PAETT_inst_exit, so only fini should be inserted.
void PAETT_inst_thread_fini(uint64_t key) {
    int tid = GET_THREADID;
    danger[tid] = false;
    // printf("thread_exit for 0x%lx @ 0x%lx\n",key,cur[tid]->key); fflush(stdout);
    PAETT_inst_exit(key);
}
#endif
void PAETT_inst_enter(uint64_t key) {
    if(danger[0] || !initialized) return;
    int retval;
    uint64_t e_cycles = PAPI_get_real_usec();
    int tid = GET_THREADID;
    INFO("Enter key=0x%lx\n",key);
    assert(tid>=0);
    assert(tid<MAX_THREAD);
    danger[tid] = true;
    assert(cur[tid]);
    // energy
    if(collect_energy) {
        double energy = get_pkg_energy();
        double e = energy - cur[tid]->data.last_energy;
        CallingContextLog* p = cur[tid];
        while(p!=NULL) {
            p->data.pkg_energy+= e;
            RLOG("Enter: Update %lx PKG energy to %.6lf (+%.6lf) J\n", p->key, p->data.pkg_energy, e);
            p = p->parent;
        }
    }
    cur[tid]->data.cycle += e_cycles - g_cycles[tid];
    //cur[tid] = cur[tid]->getOrInsertChild(key, !detection_mode);
    cur[tid] = cur[tid]->getOrInsertChild(key);
    //printf("Enter key=0x%lx context length = %ld\n", key, cur[tid]->length()); fflush(stdout);
    //assert((cur[tid]->length()<=50) && "Too deep (>50) calling context!!!");
    ++(cur[tid]->data.ncall);
    if(!detection_mode && cur[tid]->data.eventData==NULL) {
        cur[tid]->data.active_thread = 1;
        cur[tid]->data.size = eventNum;
        cur[tid]->data.eventData = __allocate_eventLogSpace(tid,eventNum*2);//(uint64_t*)malloc(sizeof(uint64_t)*eventNum*2);
        // memset(cur[tid]->data.eventData, 0, sizeof(uint64_t)*eventNum);
    }
    assert(cur[tid]);
    danger[tid] = false;
    // printf("PAPI Collect? %d %d\n",detection_mode, cur[tid]->pruned);
    if(!detection_mode && (!cur[tid]->pruned)) {
        // printf("Collect for PAPI %0xlx\n",key);
        CHECK_PAPI_ISOK(PAPI_read(EventSet, &(cur[tid]->data.eventData[eventNum])));
    }
    if(collect_energy) {
        cur[tid]->data.last_energy = get_pkg_energy();
    }
    g_cycles[tid] = PAPI_get_real_usec();
}

void PAETT_inst_exit(uint64_t key) {
    if(danger[0] || !initialized) return;
    int retval;
    uint64_t e_cycles = PAPI_get_real_usec();
    int tid = GET_THREADID;
    INFO("Exit key=0x%lx\n",key);
    assert(tid>=0);
    assert(tid<MAX_THREAD);
    danger[tid] = true;
    // energy
    if(collect_energy) {
        double energy = get_pkg_energy();
        double e = energy - cur[tid]->data.last_energy;
        CallingContextLog* p = cur[tid];
        while(p!=NULL) {
            p->data.pkg_energy+= e;
            RLOG("Enter: Update %lx PKG energy to %.6lf (+%.6lf) J\n", p->key, p->data.pkg_energy, e);
            p = p->parent;
        }
    }
    if(!detection_mode && (!cur[tid]->pruned)) {
        CHECK_PAPI_ISOK(PAPI_read(EventSet, counterVal));
    }
    assert(cur[tid]);
    if(cur[tid]->key==key) {
        cur[tid]->data.cycle += e_cycles - g_cycles[tid];
        if(!detection_mode && (!cur[tid]->pruned)) {
            // Dynamically prune the context
            if(cur[tid]->data.ncall>=CHECK_THRESHOLD && cur[tid]->data.cycle/cur[tid]->data.ncall < PRUNE_THRESHOLD) {
                // cur[tid]->printStack();
                cur[tid]->pruned = true;
            }
            uint64_t i;
            for(i=0;i<eventNum;++i) {
                cur[tid]->data.eventData[i] += counterVal[i] - cur[tid]->data.eventData[i+eventNum];
            }
        }
        assert(cur[tid]!=root[tid]);
        assert(cur[tid]->parent);
        cur[tid] = cur[tid]->parent;
    } else {
#ifdef ENABLE_INFO_LOG
        printf("Warning: [libpaett_inst] paett_inst_exit not handled as key (cur=0x%lx, key=0x%lx) is not same !!!\n",cur[tid]->key, key);
        cur[tid]->printStack();
        fflush(stdout);
#endif
#ifdef STOP_WHEN_WARN
        if (auto warn = cur[tid]->findStack(key)) {
            printf("Error: Something May wrong as this key appears as current context's parent:\n");
            warn->printStack();
            exit(-1);
        } else {
            assert("Warning detected. Stop.");   
        }
#else
        if (auto warn = cur[tid]->findStack(key)) {
            printf("Warning: [libpaett_inst] paett_inst_exit not handled as key (cur=0x%lx, key=0x%lx) is not same !!!\n",cur[tid]->key, key);
            warn->printStack();
            cur[tid] = warn;
        }
#endif
    }
    
    danger[tid] = false;
    if(collect_energy) {
        cur[tid]->data.last_energy = get_pkg_energy();
    }
    g_cycles[tid] = PAPI_get_real_usec();
}

void PAETT_inst_finalize() {
    // disable first
    int retval;
    if(detection_mode) {
        __PAETT_detect_finalize();
        return ;
    }
    CHECK_PAPI_ISOK(PAPI_stop(EventSet, counterVal));
    uint64_t end_us = PAPI_get_real_usec();
    uint64_t end_cyc = PAPI_get_real_cyc();
    elapsed_us = end_us - elapsed_us;
	elapsed_cyc = end_cyc - elapsed_cyc;
    printf("INFO : Elasped us: %lu\n", elapsed_us);
    printf("INFO : Elasped cyc: %lu\n", elapsed_cyc);
    int i,j,k;
    for(i=0;i<eventNum+1;++i) {
        printf("INFO : TOTAL Counter Value[%d] = %ld\n", i, counterVal[i]); fflush(stdout);
    }
    fclose(LOG);
    int tid;
    elapsed_us_multi[0] = elapsed_us;
    std::string gprof_fn = profile_path+std::string(PAETT_GENERAL_PROF_FN);
#ifdef MULTI_THREAD
    FILE* fp = fopen(gprof_fn.c_str(), "w");
    //fprintf(fp, "%ld", elapsed_us);
    for(tid=0;tid<MAX_THREAD;++tid) {
        // if the root is not initialized, next;
        if(root[tid]->data.ncall==0) continue;
        printf("\n======== THREAD ID = %d, elasped time = %ld ==========\n",tid, elapsed_us_multi[tid]);
        fprintf(fp," %ld",elapsed_us_multi[tid]);
#else
    FILE* fp = fopen(gprof_fn.c_str(), "w");
    fprintf(fp, "%ld", elapsed_us);
    fclose(fp);
    tid=0;
#endif
    // ROOT data.nall should not be modified during execution
    assert(root[tid]->data.ncall==1);
    // ROOT data.ncall should be set to 1 as the program is called once
    // root[tid].data.ncall = 1;
    assert(root[tid]->data.eventData!=NULL);
    if(cur[tid]!=root[tid]) {
        printf("Warning: [libpaett_inst] cur[%d] is not at root when paett_inst_finalize is called : ",tid);
        CallingContextLog* p = cur[0]->parent;
        printf("cur=[%lu] ",cur[0]->key); 
        while(p!=NULL) { printf("<= [%lu] ",p->key); p=p->parent; }
        printf("\n");
    }
    // CallingContextLog::print(&root[0]);
#ifdef VERBOSE_DISTRIBUTION
    printDistribution(root[tid], elapsed_us_multi[tid]);
#endif
    std::string prof_fn = profile_path+std::string(PAETT_PERF_INSTPROF_FN)+"."+std::to_string(tid);
    CallingContextLog::fprint(prof_fn.c_str(), root[tid]);
    prof_fn = profile_path+std::string(KEYMAP_FN)+"."+std::to_string(tid);
    FILE* fkey = fopen(prof_fn.c_str(), "w");
    if(fkey!=NULL) {
        printf("Wring keymap to %s\n",prof_fn.c_str());
        CallingContextLog::fprintKeyString(fkey, root[tid]);
        fclose(fkey);
    } else {
        printf("Could not open %s to log keymap info!\n",prof_fn.c_str());
    }
#ifdef MULTI_THREAD
    }
    fclose(fp);
#endif
    printf("=== finish ===\n"); fflush(stdout);
    __preallocate_fini();
    initialized = false;
}