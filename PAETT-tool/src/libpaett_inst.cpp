#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif
#include <sched.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <stdint.h>
#include <signal.h>
#include <papi.h>
#include <cassert>
#include <string.h>

#include <sys/file.h>
#include <unistd.h>

// #define PREALLOCATE_CCT
#define MULTI_THREAD
#define USE_OPENMP 1
//#define USE_PTHREAD

#include "CallingContextTree.h"
#include "common.h"
// configure file auto generated by PAETT configuration
#include "config.h"

#include <sys/syscall.h> 
#define MAXEVENT 10

#define METRIC_FN "metric.out"

#ifdef MULTI_THREAD
#define MAX_THREAD 1
#define GET_THREADID (uint64_t)PAPI_thread_id()
#define THREAD_HANDLER pthread_self
#ifdef USE_PTHREAD
    #define GET_ACTIVE_THREAD_NUM 28
#elif (USE_OPENMP==1)
    #include <omp.h>
    #define GET_ACTIVE_THREAD_NUM std::max(omp_get_max_threads(),0)
#else
    #error "Only USE_PTHREAD or USE_OPENMP is supportted!"
#endif
#else
#define MAX_THREAD 1
#define GET_THREADID 0
#define GET_ACTIVE_THREAD_NUM 1
#endif

#ifdef ENABLE_DEBUG_LOG
FILE* RAPL_LOG;
#define RAPL_LOG_FN "energy_utils.log"
#define RLOG_INIT do { RAPL_LOG = fopen(RAPL_LOG_FN, "a+"); if(!RAPL_LOG) printf("Error to open RAPL_LOG: %s\n", RAPL_LOG_FN); } while(0)
#define RLOG(msg, ...) if(RAPL_LOG) fprintf(RAPL_LOG, msg, ##__VA_ARGS__)
#define RLOG_FINI fclose(RAPL_LOG)
#else
#define RLOG_INIT 
#define RLOG(msg, ...) 
#define RLOG_FINI 
#endif

// freqmod can be enabled by setting environment variable PAETT_ENABLE_FREQMOD as 'ENABLE'
#define USE_NAMESPACE
#include "libpaett_freqmod_cct.cpp"

static bool enable_freqmod = false;
static uint64_t* eventDataBuffer[MAX_THREAD];
static uint64_t eventDataBufferIndex[MAX_THREAD];
static CallingContextLog* root[MAX_THREAD];
static CallingContextLog* cur[MAX_THREAD] = {0};
static int danger = 0;
static int* _eventList;
// PAPI global vars
static uint8_t initialized = 0;
static int EventSet = PAPI_NULL;
static int eventNum = 0;
uint64_t elapsed_us;
uint64_t elapsed_cyc;

uint64_t elapsed_us_multi[MAX_THREAD] = {0};
uint64_t begin_us_multi[MAX_THREAD];

uint64_t main_thread_id;

//#define STOP_WHEN_WARN
//#define ENABLE_INFO_LOG
#ifdef ENABLE_INFO_LOG
#define INFO(msg, ...) printf("INFO: "); printf(msg, ##__VA_ARGS__); fflush(stdout)
#else
#define INFO(msg, ...)
#endif

#ifdef DEBUG_PAPI
#define CHECK_PAPI(stmt, PASS) printf("%s:%d: Executing %s\n",__FILE__, __LINE__,#stmt); fflush(stdout); if((retval=stmt)!=PASS) handle_error(retval)
#else
#define CHECK_PAPI(stmt, PASS) if((retval=stmt)!=PASS) handle_error(retval)
#endif
#define CHECK_PAPI_ISOK(stmt) CHECK_PAPI(stmt, PAPI_OK)
#define handle_error(e) do { fprintf(stderr, "Error at %s:%d: %s\n",__FILE__, __LINE__, PAPI_strerror(e)); exit(1); } while(0)

// C-style interfaces for lib call
extern "C" void PAETT_print();
extern "C" void PAETT_inst_init();
extern "C" void PAETT_inst_enter(uint64_t key); // key = MAKE_KEY(mid, l_key)
extern "C" void PAETT_inst_exit(uint64_t key);
extern "C" void PAETT_inst_thread_init(uint64_t key); // key = MAKE_KEY(mid, l_key)
extern "C" void PAETT_inst_thread_fini(uint64_t key);
extern "C" void PAETT_inst_finalize();

// Debug logging
#define LIBPAETT_INST_LOGFN "libpaett_inst.log"
static FILE* LOG;

#include "energy_utils.h"

#define COUNT_FN ".paett_collect.cnt"
#define METRIC_FN "metric.out"

// TODO: check for how gdb detects the thread launching and replace the Linux-hacked method with more genereric method
/**********************************************************
 * hacking thread to detect external thread launching     *
 * Read /proc/self/task directory and check the number of *
 * contents (running threads). We consider a parallel     *
 * region exists when multiple threads (>1) are detected. *
 * The detected parallelization will be tagged into the   *
 * current node of calling context tree (thread-safe).    *
 **********************************************************/
#include <sys/types.h>
#include <dirent.h>
#include <thread>
#include <mutex>
std::thread* parallel_monitor;
std::mutex cct_mtx;
bool __enable_parallel_detect = false;
// detection and update need to atomic to enter/exit functions to avoid tagging to wrong node
void __detectAndUpdate_parallel_tag() {
    cct_mtx.lock();
    // printf("root [%p]: active_thread = %ld\n", root[0], root[0]->data.active_thread);
    // only try to detect and update when no other active threads are recorded
    if(root[0]->data.active_thread<=1) {
        DIR *proc_dir;
        char dirname[]="/proc/self/task";
        proc_dir = opendir(dirname);
        if (proc_dir) {
            /* /proc available, iterate through tasks... */
            struct dirent *entry;
            int tnum = 0;
            while ((entry = readdir(proc_dir)) != NULL) {
                if(entry->d_name[0] == '.')
                    continue;
                ++tnum;
            }
            // main thread (parent) + monitor thread (mine)
            if(tnum>2) {
                // printf("[key=%ld] detect thread num: %d\n", root[0]->key, tnum);
                // other threads detected, it must be a parallel region, update
                root[0]->data.active_thread = tnum-1; // except monitoring thread
            }
            closedir(proc_dir);
        } else {
            printf("[FETAL ERROR!!!!] Could not open directory %s!", dirname);
            cct_mtx.unlock();
            exit(1);
        }
    }
    cct_mtx.unlock();
}

void __thread_monitor() {
    printf("================ Thread monitor launched ==================\n");
    while(__enable_parallel_detect) {
        __detectAndUpdate_parallel_tag();
        usleep(1); // 1 us
    }
}

void __init_parallel_detect() {
    printf("Init monitor threads for parallel detection\n");
    __enable_parallel_detect = true;
    parallel_monitor = new std::thread(__thread_monitor);
}

void __finalize_parallel_detect() {
    __enable_parallel_detect = false;
    parallel_monitor->join();
    delete parallel_monitor;
}
/*********************************************/

void PAETT_print() {
#ifndef DISABLE_PAPI_SAMPLING
    printf("\n=========== USING PAPI & Instrumentation =============\n");
#else
    printf("\n============ ONLY USING Instrumentation ==============\n");
#endif
#ifdef MULTI_THREAD
    printf("========== Multi Thread Support Enabled!! ============\n");
#else
    printf("========= Multi Thread Support Disabled!! ============\n");
#endif
}

static std::vector<std::string> ename;
int es, ee;

static bool detection_mode = false;
static bool collect_energy = false;
static bool generate_keymap= false;
static double init_energy;

// built-in metrics, can be modified by environment/file configurations
static const char* _pre_ename[MAXEVENT] = {
    "ENERGY",
    "PAPI_BR_NTK",
    "PAPI_LD_INS",
    "PAPI_L2_ICR",
    "PAPI_BR_MSP", // PEBS
    "PAPI_RES_STL",
    "PAPI_SR_INS", // PEBS
    "PAPI_L2_DCR" // PEBS
};
static int _pre_esize = 8;

static long long counterVal[MAXEVENT] = {0};
static uint64_t g_cycles[MAX_THREAD] = {0};

static std::string profile_path;
static std::string keymap_path;

#define SIGNIFICANT_REGION_DETECT_LOG "paett_filter.cct"

int warn_time;

bool __PAETT_detect_init() {
    char* detectEnv = getenv("PAETT_DETECT_MODE");
    char* detectResEnv = getenv("PAETT_DETECT_RES_PATH");
    if(detectEnv && std::string(detectEnv)=="ENABLE") {
        detection_mode = true;
        for(int i=0;i<MAX_THREAD;++i) {
            root[i] = CallingContextLog::get();
            cur[i]=root[i];
            cur[i]->data.size = 0;
        }
        int retval;
        CHECK_PAPI(PAPI_library_init(PAPI_VER_CURRENT), PAPI_VER_CURRENT);
#ifdef MULTI_THREAD
        CHECK_PAPI_ISOK(PAPI_thread_init(THREAD_HANDLER));
#endif
        printf("INFO: Will Running in detection mode for significant region detection\n");
        detection_mode = true;
        generate_keymap= true;
        __init_parallel_detect();
    } else if(detectResEnv) {
        FILE* fp = fopen(detectResEnv,"rb");
        if(fp==NULL) {
            printf("FILE %s could not open!\n", detectResEnv);
            exit(1);
        }
        root[0] = CallingContextLog::get();
        CallingContextLog* rd = CallingContextLog::read(fp);
        root[0]->copyCCT(rd);
        rd->clear();
        CallingContextLog::free(rd);
        fclose(fp);
        detection_mode = false;
    } else {
        detection_mode = false;
    }
    return detection_mode;
}

void __PAETT_detect_finalize() {
    __finalize_parallel_detect();
    pruneCCTWithThreshold(root[0], PRUNE_THRESHOLD, false/*don't delete the pruned nodes now*/);
    char* detectResEnv = getenv("PAETT_DETECT_RES_PATH");
    if(detectResEnv) {
        CallingContextLog::fprint(detectResEnv, root[0]);
    } else {
        CallingContextLog::fprint(LIBPAETT_INST_LOGFN, root[0]);
    }
}

uint64_t* __allocate_eventLogSpace(int i, uint64_t s) {
    assert(i>=0);
    assert(i<MAX_THREAD);
    //printf("[%d]: Allocate Size %lu B, Avail %lu B, Used %lu B\n",i, s, (eventNum*2*CCT_PREALLOCATE_SIZE)-eventDataBufferIndex[i], eventDataBufferIndex[i]);
    //fflush(stdout);
    uint64_t* res = &(eventDataBuffer[i][eventDataBufferIndex[i]]);
    eventDataBufferIndex[i]+=s;
    assert(eventDataBufferIndex[i]<=eventNum*2*CCT_PREALLOCATE_SIZE);
    return res;
}

void __preallocate_fini() {
    if(eventNum>0) {
        for(int i=0;i<MAX_THREAD;++i) {
            free(eventDataBuffer[i]);
        }
    }
}

void PAETT_inst_init() {
    int retval, i;
    if(initialized) {
        fprintf(stderr, "Error Duplicated initialization!!!\n");
        exit(EXIT_FAILURE);
    }
    main_thread_id = pthread_self();
    char* freqmodEnv = getenv("PAETT_ENABLE_FREQMOD");
    enable_freqmod = (freqmodEnv && std::string(freqmodEnv)=="ENABLE");
    if(enable_freqmod) {
        freqmod_cct::FUNCNAME(PAETT_print)();
        freqmod_cct::FUNCNAME(PAETT_inst_init)();
    }
    // PROFILE PATH
    char* envPath = getenv("PAETT_OUTPUT_PATH");
    if(envPath) {
        profile_path = std::string(envPath);
    } else {
        profile_path = std::string("./");
    }
    envPath = getenv("PAETT_KEYMAP_PATH");
    if(envPath) {
        keymap_path = std::string(envPath);
        generate_keymap = true;
    } else {
        keymap_path = std::string(KEYMAP_FN);
    }
    warn_time = 0;
    LOG = fopen(LIBPAETT_INST_LOGFN,"w");
    if(__PAETT_detect_init()) {
        ++(cur[0]->data.ncall);
        initialized = true;
        eventNum = 0;
        g_cycles[0] = PAPI_get_real_usec();
        assert(detection_mode);
        return;
    }
    assert(!detection_mode);
    // check PAPI counters from environment
    char* eEnv = getenv("PAETT_PROFILE_EVENTS");
    if(eEnv) {
        printf("*** PAETT_PROFILE_EVENTS=%s ***\n", eEnv);
        int i = 0;
        int len = strlen(eEnv);
        while(i<len) {
            char* cur = &eEnv[i];
            while(eEnv[i]!=';' && i<len) ++i;
            // if seperator found, replace it with '\0', indicating that the end of this event string
            if(i<len) {
                eEnv[i]='\0';
                ++i; // skip this seperator in the next iteration
            }
            std::string event(cur);
            if(event==std::string("ENERGY")) {
                collect_energy = true;
            } else {
                ename.push_back(event);
            }
        }
    } else {
        // if environment is not set, check for config file
        FILE* efile = fopen("profile.event","r");
        if(efile==NULL) {
            printf("INFO: profile.event not found for profiling! Use predefined event set.\n");
            int i;
            for(i=0;i<_pre_esize;++i) {
                std::string en_str = std::string(_pre_ename[i]);
                if(en_str==std::string("ENERGY")) {
                    collect_energy = true;
                } else {
                    ename.push_back(en_str);
                }
            }
        } else {
            char en[50];
            while(EOF!=fscanf(efile, "%s", en)) {
                std::string en_str = std::string(en);
                if(en_str==std::string("ENERGY")) {
                    collect_energy = true;
                } else {
                    ename.push_back(en_str);
                }
            }
            fclose(efile);
        }
    }
    // other settings
    eventNum=ename.size(); 
    // preallocate cct nodes and data spaces for metrics
    for(i=0;i<MAX_THREAD;++i) {
        root[i] = CallingContextLog::get();
        cur[i]=root[i];
        cur[i]->data.size = eventNum;
        if(eventNum>0) {
            eventDataBuffer[i] = (uint64_t*)malloc(sizeof(uint64_t)*eventNum*2*CCT_PREALLOCATE_SIZE);
            if(eventDataBuffer[i]==NULL) {
                printf("Failed to allocate memory!!!\n");
                exit(1);
            }
            memset(eventDataBuffer[i], 0, sizeof(uint64_t)*eventNum*2*CCT_PREALLOCATE_SIZE);
            eventDataBufferIndex[i] = 0;
            cur[i]->data.eventData = __allocate_eventLogSpace(i, eventNum*2);// (uint64_t*)malloc(sizeof(uint64_t)*eventNum*2);
        }
    }
    /* Initialize the PAPI library */
    CHECK_PAPI(PAPI_library_init(PAPI_VER_CURRENT), PAPI_VER_CURRENT);
#ifdef MULTI_THREAD
    CHECK_PAPI_ISOK(PAPI_thread_init(THREAD_HANDLER));
#endif
    // if(eventNum<=0) return ; // no perf event encountered
    if(eventNum>0) {
        int* eventList = (int*)malloc(sizeof(int)*eventNum);
#ifdef MULTI_THREAD
        _eventList = eventList;
#endif
        // check for available counters
        // int numCounter = PAPI_num_counters();
        int numCounter = PAPI_num_hwctrs();
        es=0, ee=eventNum;
        if(eventNum>numCounter) {
            printf("Error: Too much event is configured (%d events but the platform only support maximum %d events at a time)\n", eventNum, numCounter);
            exit(1);
        }
        //assert(GET_THREADID==0);
        printf("NumCounter: %d, Will Add %d Events\n",numCounter, eventNum); fflush(stdout);
        /* Create the EventSet */
        CHECK_PAPI_ISOK(PAPI_create_eventset(&EventSet)); fflush(stdout);
        printf("EventSet: %d\n", EventSet);
        /* Add Events to our created EventSet */
        for(i=es;i<ee;++i) {
            //CHECK_PAPI_ISOK(PAPI_event_code_to_name(eventList[i], ename));
            CHECK_PAPI_ISOK(PAPI_event_name_to_code(ename[i].c_str(), &eventList[i]));
            printf("Add Event: [%lx]", eventList[i]);  fflush(stdout);
            printf("%s\n", ename[i].c_str()); fflush(stdout);
            CHECK_PAPI_ISOK(PAPI_add_event(EventSet, eventList[i]));
        }
    }
    /* Init for energy collection if enabled */
    if(collect_energy) {
        if(energy_init()!=0) {
            printf("Energy Collection Initialization Failed!\n");
            exit(1);
        }
    }
    /* Start counting */
    elapsed_us = PAPI_get_real_usec();
	elapsed_cyc = PAPI_get_real_cyc();
    if(eventNum>0) {
        CHECK_PAPI_ISOK(PAPI_start(EventSet));
        CHECK_PAPI_ISOK(PAPI_read(EventSet, &(cur[0]->data.eventData[eventNum])));
    }
    ++(cur[0]->data.ncall);
    initialized = 1;
    init_energy = get_pkg_energy();
    cur[0]->data.last_energy = init_energy;
    g_cycles[0] = PAPI_get_real_usec();
}
#ifdef MULTI_THREAD
// actually should be inserted after PAETT_inst_enter
void PAETT_inst_thread_init(uint64_t key) {
    // fprintf(stderr,"THREAD_INIT... initilzed=%d, tid=%d\n", initialized, GET_THREADID);
    if(!initialized) return;
    // int retval, i;
    // // CHECK_PAPI_ISOK(PAPI_stop(EventSet, counterVal));
    int tid = 0;
    if(GET_THREADID!=main_thread_id) return;
    // fprintf(stderr,"thread_init for 0x%lx @ 0x%lx: tid=%d,danger=%d,initialized=%d\n",key,cur[tid]->key,tid,danger[tid],initialized); fflush(stderr);
    assert(tid<MAX_THREAD && "Thread number exceeds preallocated size!!!");
    assert(cur[tid]);
    if(enable_freqmod) {
        freqmod_cct::FUNCNAME(PAETT_inst_thread_init)(key);
    }
    // if(cur[tid]->key!=key) {
    //     PAETT_inst_enter(key);
    //     // printf("After Enter: thread_init for 0x%lx @ 0x%lx\n",key,cur[tid]->key); fflush(stdout);
    // }
    PAETT_inst_enter(key);
    ++danger;
    // // we should have already called PAETT_inst_enter
    // assert(cur[tid]);
    // assert(cur[tid]->key==key);
    // Stop counting first to disable overflow
    cur[tid]->data.active_thread = std::max(cur[tid]->data.active_thread, (uint64_t)GET_ACTIVE_THREAD_NUM);
    // printf("[key=%ld] active thread: %ld\n",cur[tid]->key,cur[tid]->data.active_thread); fflush(stdout);
}
// Different from init, the fini instrumentation will do the work similiarly as PAETT_inst_exit, so only fini should be inserted.
void PAETT_inst_thread_fini(uint64_t key) {
    if(!initialized) return;
    int tid = 0;//GET_THREADID;
    if(GET_THREADID==main_thread_id) --danger;
    // printf("thread_exit for 0x%lx @ 0x%lx\n",key,cur[tid]->key); fflush(stdout);
    PAETT_inst_exit(key);
    if(enable_freqmod) {
        freqmod_cct::FUNCNAME(PAETT_inst_thread_fini)(key);
    }
}
#endif
static uint64_t cct_num = 0;
void PAETT_inst_enter(uint64_t key) {
// #ifdef USE_OPENMP
//     // if key==0, it indicates that this is .omp functions that force to insert a enter function
//     // and if currently it is not in parallel region, we should not handle this enter request.
//     if(!omp_in_parallel() && key==0) return;
// #endif
    if(enable_freqmod) {
        freqmod_cct::FUNCNAME(PAETT_inst_enter)(key);
    }
    if(!initialized) return;
// #ifdef USE_OPENMP
//     if(omp_in_parallel()) return;
// #endif
    int tid = 0;//GET_THREADID;
    //printf("[INFO] TID=%ld, main_thread_id=%ld\n", GET_THREADID, main_thread_id);
    if(GET_THREADID!=main_thread_id) return;
    // if(tid!=0) return;
    //printf("[DEBUG] %lx %s, %ld, %ld\n", key, reinterpret_cast<char*>(key), ++cct_num, (1L<<10));
    int retval;
    uint64_t e_cycles = PAPI_get_real_usec();
    INFO("Enter key=0x%lx\n",key);
    assert(tid>=0);
    assert(tid<MAX_THREAD);
    assert(cur[tid]);
    // cct mutex needs to be locked to avoid data race of current cct node with monitoring thread.
    cct_mtx.lock();
    {
        // energy
        if(collect_energy) {
            double energy = get_pkg_energy();
            double e = energy - cur[tid]->data.last_energy;
            CallingContextLog* p = cur[tid];
            while(p!=NULL) {
                p->data.pkg_energy+= e;
                RLOG("Enter: Update %lx PKG energy to %.6lf (+%.6lf) J\n", p->key, p->data.pkg_energy, e);
                p = p->parent;
            }
        }
        cur[tid]->data.cycle += e_cycles - g_cycles[tid];
        cur[tid] = cur[tid]->getOrInsertChild(key, !detection_mode/*default self end*/);
        //printf("Enter key=0x%lx context length = %ld\n", key, cur[tid]->length()); fflush(stdout);
        //assert((cur[tid]->length()<=50) && "Too deep (>50) calling context!!!");
        ++(cur[tid]->data.ncall);
        // if(detection_mode) {
        //     cur[tid]->data.active_thread = 1;
        //     cur[tid]->data.size = 0;
        //     cur[tid]->data.eventData = NULL;
        // }
        if(!detection_mode && cur[tid]->data.eventData==NULL && (!cur[tid]->pruned)) {
            cur[tid]->data.active_thread = 1;
            cur[tid]->data.size = eventNum;
            if(eventNum>0)
                cur[tid]->data.eventData = __allocate_eventLogSpace(tid,eventNum*2);//(uint64_t*)malloc(sizeof(uint64_t)*eventNum*2);
            // memset(cur[tid]->data.eventData, 0, sizeof(uint64_t)*eventNum);
        }
        assert(cur[tid]);
        // printf("PAPI Collect? %d %d\n",detection_mode, cur[tid]->pruned);
        if(!detection_mode && (!cur[tid]->pruned)  && eventNum>0) {
            // printf("Collect for PAPI %0xlx\n",key);
            CHECK_PAPI_ISOK(PAPI_read(EventSet, &(cur[tid]->data.eventData[eventNum])));
        }
        if(collect_energy) {
            cur[tid]->data.last_energy = get_pkg_energy();
        }
    } // locking region
    // release lock
    cct_mtx.unlock();
    g_cycles[tid] = PAPI_get_real_usec();
}

void PAETT_inst_exit(uint64_t key) {
// #ifdef USE_OPENMP
//     // if key==0, it indicates that this is .omp functions that force to insert a exit function
//     // and if currently it is not in parallel region, we should not handle this exit request.
//     if(!omp_in_parallel() && key==0) return;
// #endif
    if(enable_freqmod) {
        freqmod_cct::FUNCNAME(PAETT_inst_exit)(key);
    }
    int tid = 0;//GET_THREADID;
    if(GET_THREADID != main_thread_id) return;
    //if(tid!=0) return;
    if(!initialized) return;
// #ifdef USE_OPENMP
//     if(omp_in_parallel()) return;
// #endif
    int retval;
    uint64_t e_cycles = PAPI_get_real_usec();
    INFO("Exit key=0x%lx\n",key);
    assert(tid>=0);
    assert(tid<MAX_THREAD);
    cct_mtx.lock();
    {
        // energy
        if(collect_energy) {
            double energy = get_pkg_energy();
            double e = energy - cur[tid]->data.last_energy;
            CallingContextLog* p = cur[tid];
            while(p!=NULL) {
                p->data.pkg_energy+= e;
                RLOG("Enter: Update %lx PKG energy to %.6lf (+%.6lf) J\n", p->key, p->data.pkg_energy, e);
                p = p->parent;
            }
        }
        if(!detection_mode && (!cur[tid]->pruned) && eventNum>0) {
            CHECK_PAPI_ISOK(PAPI_read(EventSet, counterVal));
        }
    redo:
        assert(cur[tid]);
        if(cur[tid]->key==key) {
            cur[tid]->data.cycle += e_cycles - g_cycles[tid];
            if(!detection_mode && (!cur[tid]->pruned)) {
                // Dynamically prune the context
                if(cur[tid]->data.ncall>=CHECK_THRESHOLD && cur[tid]->data.cycle/cur[tid]->data.ncall < PRUNE_THRESHOLD) {
                    // cur[tid]->printStack();
                    cur[tid]->pruned = true;
                }
                uint64_t i;
                for(i=0;i<eventNum;++i) {
                    cur[tid]->data.eventData[i] += counterVal[i] - cur[tid]->data.eventData[i+eventNum];
                }
            }
            assert(cur[tid]!=root[tid]);
            assert(cur[tid]->parent);
            cur[tid] = cur[tid]->parent;
        } else {
            if(detection_mode) {
                printf("Warning: [libpaett_inst] paett_inst_exit not handled as key (cur=0x%lx(%s), key=0x%lx(%s)) is not same !!!\n",cur[tid]->key, cur[tid]->key==(uint64_t)(-1)?"ROOT":reinterpret_cast<char*>(cur[tid]->key), key, key==(uint64_t)(-1)?"ROOT":reinterpret_cast<char*>(key));
            } else {
                printf("Warning: [libpaett_inst] paett_inst_exit not handled as key (cur=0x%lx, key=0x%lx) is not same !!!\n",cur[tid]->key, key);
            }
    #ifdef DEBUG
    #ifdef ENABLE_INFO_LOG
            printf("Warning: [libpaett_inst] paett_inst_exit not handled as key (cur=0x%lx, key=0x%lx) is not same !!!\n",cur[tid]->key, key);
            cur[tid]->printStack();
            fflush(stdout);
    #endif
    #ifdef STOP_WHEN_WARN
            if (auto warn = cur[tid]->findStack(key)) {
                printf("Error: Something May wrong as this key appears as current context's parent:\n");
                warn->printStack();
                exit(-1);
            } else {
                assert("Warning detected. Stop.");   
            }
    #else
            if (auto warn = cur[tid]->findStack(key)) {
                cur[tid] = warn;
                goto redo;
            } else {
                /* this debug information needs to be compiled without any frequency modification support 
                (as freqmod will make key a integer, not a pointer to a string of debug info) */
                if(warn_time<10) {
                    printf("Warning: [libpaett_inst] paett_inst_exit not handled as key (cur=0x%lx(%s), key=0x%lx(%s)) is not same !!!\n",cur[tid]->key, (cur[tid]->key==CCT_ROOT_KEY?"ROOT":reinterpret_cast<char*>(cur[tid]->key)), key, (key==CCT_ROOT_KEY?"ROOT":reinterpret_cast<char*>(key)));
                    cur[tid]->printStack();
                }
                ++warn_time;
            }
    #endif
    #endif// DEBUG
        }
        if(collect_energy) {
            cur[tid]->data.last_energy = get_pkg_energy();
        }
    } // locking region
    cct_mtx.unlock();
    g_cycles[tid] = PAPI_get_real_usec();
}

void __generate_keymap(CallingContextLog* root) {
    std::string prof_fn = profile_path+keymap_path;
    FILE* fkey = fopen(prof_fn.c_str(), "w");
    if(fkey!=NULL) {
        printf("Wring keymap to %s\n",prof_fn.c_str());
        CallingContextLog::fprintKeyString(fkey, root);
        fclose(fkey);
    } else {
        printf("Could not open %s to log keymap info!\n",prof_fn.c_str());
    }
}

void PAETT_inst_finalize() {
    // disable first
    int retval;
    // energy
    uint64_t e_cycles = PAPI_get_real_usec();
    if(collect_energy) {
        double energy = get_pkg_energy();
        double e = energy - cur[0]->data.last_energy;
        CallingContextLog* p = cur[0];
        while(p!=NULL) {
            p->data.pkg_energy+= e;
            RLOG("Enter: Update %lx PKG energy to %.6lf (+%.6lf) J\n", p->key, p->data.pkg_energy, e);
            p = p->parent;
        }
    }
    if(!detection_mode && (!cur[0]->pruned) && eventNum>0) {
        CHECK_PAPI_ISOK(PAPI_read(EventSet, counterVal));
    }
    cur[0]->data.cycle += e_cycles - g_cycles[0];
    if(!detection_mode && (!cur[0]->pruned)) {
        uint64_t i;
        for(i=0;i<eventNum;++i) {
            cur[0]->data.eventData[i] += counterVal[i] - cur[0]->data.eventData[i+eventNum];
        }
    }
    if(detection_mode) {
        __PAETT_detect_finalize();
        if(generate_keymap) __generate_keymap(root[0]);
        initialized = false;
        return ;
    }
    if(eventNum>0)
        CHECK_PAPI_ISOK(PAPI_stop(EventSet, counterVal));
    uint64_t end_us = PAPI_get_real_usec();
    uint64_t end_cyc = PAPI_get_real_cyc();
    elapsed_us = end_us - elapsed_us;
	elapsed_cyc = end_cyc - elapsed_cyc;
    printf("INFO : Elasped us: %lu\n", elapsed_us);
    printf("INFO : Elasped cyc: %lu\n", elapsed_cyc);
    int i,j,k;
    for(i=0;i<eventNum+1;++i) {
        printf("INFO : TOTAL Counter Value[%d] = %ld\n", i, counterVal[i]); fflush(stdout);
    }
    fclose(LOG);
    int tid;
    elapsed_us_multi[0] = elapsed_us;
    std::string gprof_fn = profile_path+std::string(PAETT_GENERAL_PROF_FN);
#ifdef MULTI_THREAD
    FILE* fp = fopen(gprof_fn.c_str(), "w");
    //fprintf(fp, "%ld", elapsed_us);
    for(tid=0;tid<MAX_THREAD;++tid) {
        // if the root is not initialized, next;
        if(root[tid]->data.ncall==0) continue;
        printf("\n======== THREAD ID = %d, elasped time = %ld ==========\n",tid, elapsed_us_multi[tid]);
        fprintf(fp," %ld",elapsed_us_multi[tid]);
#else
    FILE* fp = fopen(gprof_fn.c_str(), "w");
    fprintf(fp, "%ld", elapsed_us);
    fclose(fp);
    tid=0;
#endif
    // ROOT data.nall should not be modified during execution
    assert(root[tid]->data.ncall==1);
    // ROOT data.ncall should be set to 1 as the program is called once
    // root[tid].data.ncall = 1;
    if(eventNum>0)
        assert(root[tid]->data.eventData!=NULL);
    if(cur[tid]!=root[tid]) {
        printf("Warning: [libpaett_inst] cur[%d] is not at root when paett_inst_finalize is called : ",tid);
        CallingContextLog* p = cur[0]->parent;
        printf("cur=[%lu] ",cur[0]->key); 
        while(p!=NULL) { printf("<= [%lu] ",p->key); p=p->parent; }
        printf("\n");
    }
    // CallingContextLog::print(&root[0]);
#ifdef VERBOSE_DISTRIBUTION
    printDistribution(root[tid], elapsed_us_multi[tid]);
#endif
    std::string prof_fn = profile_path+std::string(PAETT_PERF_INSTPROF_FN)+"."+std::to_string(tid);
    CallingContextLog::fprint(prof_fn.c_str(), root[tid]);
    if(generate_keymap) {
        __generate_keymap(root[tid]);
    }
#ifdef MULTI_THREAD
    }
    fclose(fp);
#endif
    __preallocate_fini();
    if(enable_freqmod) {
        freqmod_cct::FUNCNAME(PAETT_inst_finalize)();
    }
    initialized = false;
    printf("=== finish ===\n"); fflush(stdout);
}