from utils.CallingContextTree import CallingContextTree, AdditionalData
from utils.executor import execute, get_metric_name
from utils.Configuration import Configuration
import argparse
import os

def get_cct_energy(cct):
    def get_energy(data):
        return data[-1]
    return cct.mergeBy(get_energy)

# [start, end], with step size *step*
def thread_search(exe, keymap_fn, start, end, step, enable_consistant_thread, enable_continue, thread_res_fn="thread.cct"):
    # temporary metric output files
    out_dir = 'thread_metrics/'
    if enable_continue:
        if not os.path.exists(out_dir):
            print("Warning: continue enabled but no existing output directory found! Disable continue and restart searching.")
            enable_continue = False
            os.mkdir(out_dir)
    else:
        if os.path.exists(out_dir):
            shutil.rmtree(out_dir)
        os.mkdir(out_dir)
    # add single thread execution as baseline
    print("Running with 1 Thread")
    res_fn = get_metric_name(out_dir, config.get_max_core(), config.get_max_uncore(), 1)
    if not (enable_continue or os.path.exists(res_fn)):
        res_fn = execute(exe, 1, config.get_max_core(), config.get_max_uncore(), keymap_fn, out_dir)
    cct = load_cct_from_metrics(None, res_fn, 1)
    energy = get_cct_energy(cct)
    if start==1:
        start = start + step
    for i in range(start, end+1, step):
        print("Running with {0} Thread".format(i))
        res_fn = get_metric_name(out_dir, config.get_max_core(), config.get_max_uncore(), i)
        if not (enable_continue or os.path.exists(res_fn)):
            tmp_cct_fn = "frequency-tmp.cct"
            with open(tmp_cct_fn, 'w') as f:
                cct.generate_frequency_commands_with(f, keyMap, config.get_max_core(), config.get_max_uncore(), i)
            res_fn = execute(exe, i, config.get_max_core(), config.get_max_uncore(), keymap_fn, out_dir, cct_fn=tmp_cct_fn)
        # thread configuration must be consistant across all ccts
        if enable_consistant_thread:
            # if consistant thread is enabled, we do not tune the thread number at runtime
            # as it may cause application's undefined behaviors (e.g. segfault, undesired low utility)
            cct_tmp = load_cct_from_metrics(None, res_fn, i)
            # set global settings as temporary return values, need to be cleared outside
            cct_tmp.thread = i
            energy_tmp = get_cct_energy(cct_tmp)
            if energy_tmp < energy:
                print("Update to Thread {0}, energy {1} J".format(i, energy_tmp))
                cct = cct_tmp
                energy = energy_tmp
        else:
            cct = load_cct_from_metrics(cct, res_fn, i)
    cct.reset_nodes()
    if thread_res_fn is not None:
        print("Save thread optimized cct to ", thread_res_fn)
        cct.saveTo(thread_res_fn)
    return cct

if __name__=='__main__':
    config = Configuration()
    parser = argparse.ArgumentParser(description='Execute scripts to obtain CCT-aware roofline metrics.')
    parser.add_argument('--exe', help='executable compiled with powerspector\'s instrumentation', default='run.sh')
    parser.add_argument('--keymap', help='keymap generated by the powerspector (with detection mode)', default='PAETT.keymap')
    parser.add_argument('--continue', help='skip execution if the output file is already exist.', action='store_true')
    parser.add_argument('--out', help='output directory', default='./')
    args = parser.parse_args()